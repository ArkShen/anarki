(test-iso "coerce nil to cons works"
   nil
   (as cons nil))


(test "copy works on lists"
  (withs (old  '(1 2 3)
          new  copy.old)
    (and (iso old new)
         (~is old new))))

(test "copy works on strings"
  (withs (old  "abc"
          new  copy.old)
    (and (iso old new)
         (not ($.eq? old new)))))  ; ugly that string copies are 'is' each other

(test "copy works on tables"
  (withs (old  (obj a 1 b 2)
          new  copy.old)
    (and (iso old new)
         (~is old new))))

(test-iso "len works on lists"
  3
  (len '(1 2 3)))

(test-iso "len of syms is 0"
  0
  (len 'a))

(test-iso "len works on improper lists"
  3
  (len '(1 2 . 3)))

(test-iso "find works on lists"
  #\b
  (find #\b '(#\a #\b #\c)))

(test-iso "find works on lists - 2"
  nil
  (find #\d '(#\a #\b #\c)))

(test-iso "find handles arbitrary predicate"
  34
  (find even '(33 34 35)))

(test-iso "find handles arbitrary predicate - 2"
  34
  (find even '(34 35)))

(test-iso "find handles arbitrary predicate - 3"
  34
  (find even '(33 34)))

(test-iso "find handles arbitrary predicate - 4"
  34
  (find even '(34)))

(test-iso "find handles arbitrary predicate - 5"
  nil
  (find even '(35)))

(test-iso "find returns first match"
  34
  (find even '(34 35 36)))

(test-iso "find works on strings"
  #\b
  (find #\b "abc"))

(test-iso "find works on strings - 2"
  nil
  (find #\d "abc"))

(test-iso "find works on improper lists"
  'a
  (find 'a '(a b . c)))

(test-iso "find works on improper lists - 2"
  'c
  (find 'c '(a b . c)))

(test-iso "find works on improper lists - 3"
  nil
  (find 'd '(a b . c)))

(test-iso "mem works"
  '(6 7)
  (mem 6 '(2 4 5 6 7)))

(test-iso "mem works on improper lists"
  '(6 . 7)
  (mem 6 '(2 4 5 6 . 7)))

(test-iso "mem works on improper lists - 2"
  6
  (mem 6 '(2 4 5 . 6)))

(test-iso "some works on improper lists"
  t
  (some odd '(2 4 5 . 6)))

(test-iso "some works on improper lists - 2"
  t
  (some 6 '(2 4 5 . 6)))

(test-iso "some works on improper lists - 3"
  nil
  (some 7 '(2 4 5 . 6)))

(test-iso "pushnew works on improper lists"
  '(2 . 3)
  (ret x 3
    (pushnew 2 x)))

(test-iso "pushnew works on improper lists - 2"
  3
  (ret x 3
    (pushnew 3 x)))

(test-iso "pushnew works with nil"
  '(nil 3)
  (ret x '(3)
    (pushnew nil x)))

(test-iso "map works with one list"
  '(2 4 6)
  (map [* _ 2] '(1 2 3)))

(test-iso "map works with multiple lists"
  '(1 4 9)
  (map * '(1 2 3) '(1 2 3)))

(test-iso "map works with one string"
  "mno"
  (map (obj #\a #\m #\b #\n #\c #\o)
       "abc"))

(test-iso "map works with multiple strings"
  "dahe"
  (map (fn (a b) (min a b))
       "dave" "john"))

(test-iso "subst works on lists"
  '(2 2 3)
  (subst 1 2 '(1 2 3)))

(test-iso "subst can take functions"
  '(2 2 2 (4 2 . 6) . 2)
  (rep:subst atom&odd 2 (tree '(1 2 3 (4 5 . 6) . 7))))

(test-iso "subst can take functions - 2"
  '(2 2 4 (4 6 . 6) . 8)
  (rep:subst atom&odd [+ _ 1] (tree '(1 2 3 (4 5 . 6) . 7))))

(test-iso "subst can replace subtrees"
  '((3 4) (5 6))
  (rep:subst '(1 2) '(3 4) (tree '((1 2) (5 6)))))

(test-iso "cut works"
  '(3 4 5)
  (cut '(1 2 3 4 5) 2))

(test-iso "cut handles end index"
  '(3 4)
  (cut '(1 2 3 4 5) 2 4))

(test-iso "cut handles max end index"
  '(3 4 5)
  (cut '(1 2 3 4 5) 2 5))

(test-iso "cut handles overlong end index"
  '(3 4 5)
  (cut '(1 2 3 4 5) 2 6))

(test-iso "cut handles negative end index"
  '(3 4)
  (cut '(1 2 3 4 5) 2 -1))

(test-iso "cut works on strings"
  "cde"
  (cut "abcde" 2))

(test-iso "cut handles end index for strings"
  "cd"
  (cut "abcde" 2 4))

(test-iso "cut handles max end index for strings"
  "cde"
  (cut "abcde" 2 5))

(test-iso "cut handles overlong end index for strings"
  "cde"
  (cut "abcde" 2 6))

(test-iso "cut handles negative end index for strings"
  "cd"
  (cut "abcde" 2 -1))

(test-iso "split chops list at given index"
  '((1 2) (3 4))
  (split '(1 2 3 4) 2))

(test-iso "split chops string at given index"
  '((1 2) (3 4))
  (split '(1 2 3 4) 2))

(test-iso "before works when both elems are present"
  t
  (before 3 4 '(1 2 3 4)))
(test-iso "before works when both elems are present - 2"
  nil
  (before 4 3 '(1 2 3 4)))

(test-iso "before works when second elem is absent"
  t
  (before 3 5 '(1 2 3 4)))

(test-iso "before works when first elem is absent"
  nil
  (before 5 3 '(1 2 3 4)))

(test-iso "before works when both elems are absent"
  nil
  (before 6 5 '(1 2 3 4)))

(test-iso "serialize works on nil"
  ()
  (serialize ()))

(test-iso "serialize works on lists"
  '(1 2 3)
  (serialize '(1 2 3)))

(test-iso "serialize works on strings"
  "abc"
  (serialize "abc"))

(test-iso "serialize works on tables"
  '(tagged table ((3 4) (1 2)))
  (serialize (obj 1 2 3 4)))

(test-iso "unserialize complements serialize for nil"
  ()
  (unserialize:serialize ()))

(test-iso "unserialize complements serialize for lists"
  '(1 2 3)
  (unserialize:serialize '(1 2 3)))

(test-iso "unserialize complements serialize for strings"
  "abc"
  (unserialize:serialize "abc"))

(test-iso "unserialize complements serialize for empty tables"
  (table)
  (unserialize:serialize (table)))

(test-iso "unserialize complements serialize for tables"
  (obj 1 2 3 4)
  (unserialize:serialize (obj 1 2 3 4)))

(test-iso "serialize operates on tables inside lists"
  '(1 (tagged table ()) 2 3)
  (serialize `(1 ,(table) 2 3)))

(test-iso "unserialize complements serialize for tables inside lists"
  `(1 ,(table) 2 3)
  (unserialize:serialize `(1 ,(table) 2 3)))

(test-iso "serialize operates on nested tables"
  '(tagged table ((2 3) (1 (tagged table ()))))
  (serialize (obj 1 (table) 2 3)))

(test-iso "unserialize complements serialize for nested tables"
  (obj 1 (table) 2 3)
  (unserialize:serialize (obj 1 (table) 2 3)))

(mac foo (x) `(let y@ (+ ,x 1) (+ y@ ,x)))
(mac foo-bad (x) `(let y (+ ,x 1) (+ y ,x)))
(test-iso "mac gensyms don't capture variables"
  7
  (let y@ 3 (foo y@)))
(test-iso "mac without gensyms does capture variables"
  8  ; probably not what you want
  (let y 3 (foo-bad y)))
